import { type FactoryAssociations } from '@src/associations';
import type {
  ModelAttrs,
  ModelId,
  ModelInstance,
  ModelTemplate,
  PartialModelAttrs,
} from '@src/model';
import type { ModelCollection } from '@src/model';
import type { SchemaCollections, SchemaInstance } from '@src/schema';
import { MirageError } from '@src/utils';

import AssociationsManager from './AssociationsManager';
import type { FactoryAttrs, FactoryAfterCreateHook, ModelTraits, TraitName } from './types';

/**
 * Factory that builds model attributes with optional schema support.
 * @template TTemplate - The model template (inferred from constructor)
 * @template TSchema - The schema collections type (never = sch)
 * @template TTraits - The factory traits (inferred from constructor)
 */
export default class Factory<
  TTemplate extends ModelTemplate = ModelTemplate,
  TSchema extends SchemaCollections = SchemaCollections,
  TTraits extends ModelTraits<TSchema, TTemplate> = {},
> {
  readonly attributes: FactoryAttrs<TTemplate>;
  readonly traits: TTraits;
  readonly associations?: FactoryAssociations<TTemplate, TSchema>;
  readonly afterCreate?: FactoryAfterCreateHook<TSchema, TTemplate>;

  private readonly _template: TTemplate;
  private readonly _associationsManager: AssociationsManager<TTemplate, TSchema>;

  constructor(
    template: TTemplate,
    attributes: FactoryAttrs<TTemplate>,
    traits: TTraits = {} as TTraits,
    associations?: FactoryAssociations<TTemplate, TSchema>,
    afterCreate?: FactoryAfterCreateHook<TSchema, TTemplate>,
  ) {
    this._template = template;
    this.attributes = attributes;
    this.traits = traits;
    this.associations = associations;
    this.afterCreate = afterCreate;

    // Create manager for processing associations
    this._associationsManager = new AssociationsManager<TTemplate, TSchema>();
  }

  /**
   * Get the model template
   * @returns The model template
   */
  get template(): TTemplate {
    return this._template;
  }

  /**
   * Build a model with the given model ID and trait names or default values.
   * @param modelId - The ID of the model to build.
   * @param traitsAndDefaults - The names of the traits to apply or default values for attributes.
   * @returns The built model.
   */
  build(
    modelId: ModelId<TTemplate>,
    ...traitsAndDefaults: (TraitName<TTraits> | PartialModelAttrs<TTemplate, TSchema>)[]
  ): ModelAttrs<TTemplate, TSchema> {
    const traitNames: string[] = [];
    const defaults: PartialModelAttrs<TTemplate, TSchema> = {};

    // Separate trait names from default values
    traitsAndDefaults.forEach((arg) => {
      if (typeof arg === 'string') {
        traitNames.push(arg);
      } else {
        Object.assign(defaults, arg);
      }
    });

    const processedAttributes = this._processAttributes(this.attributes, modelId);
    const traitAttributes = this._buildWithTraits(traitNames, modelId);

    // Merge attributes in order: defaults override traits, traits override base attributes
    const mergedAttributes = this._mergeAttributes(processedAttributes, traitAttributes);

    // Add user defaults and the autogenerated id
    return {
      ...mergedAttributes,
      ...defaults,
      id: modelId,
    } as ModelAttrs<TTemplate, TSchema>;
  }

  /**
   * Process associations and return relationship values
   * This runs with schema context and creates/links related models
   * @param schema - The schema instance
   * @param skipKeys - Optional list of relationship keys to skip (e.g., if user provided them)
   * @param traitsAndDefaults - Optional trait names to include trait associations
   * @returns A record of relationship values
   */
  processAssociations(
    schema: SchemaInstance<TSchema>,
    skipKeys?: string[],
    traitsAndDefaults?: (TraitName<TTraits> | PartialModelAttrs<TTemplate, TSchema>)[],
  ): Record<string, ModelInstance<any, TSchema> | ModelCollection<any, TSchema>> {
    // Get trait associations
    const traitAssociations = this._getTraitAssociations(traitsAndDefaults);

    // Merge factory associations with trait associations (factory associations take precedence)
    const mergedAssociations = {
      ...traitAssociations,
      ...(this.associations || {}),
    };

    // If no associations, return empty
    if (Object.keys(mergedAssociations).length === 0) {
      return {};
    }

    // Use the manager instance to process merged associations
    return this._associationsManager.processAssociations(schema, mergedAssociations, skipKeys);
  }

  /**
   * Process the afterCreate hook and the trait hooks.
   * This method is intended to be called internally by schema collections.
   * @param schema - The schema instance.
   * @param model - The model to process.
   * @param traitsAndDefaults - The traits and defaults that were applied.
   * @returns The processed model.
   */
  processAfterCreateHooks(
    schema: SchemaInstance<TSchema>,
    model: ModelInstance<TTemplate, TSchema>,
    ...traitsAndDefaults: (TraitName<TTraits> | PartialModelAttrs<TTemplate, TSchema>)[]
  ): ModelInstance<TTemplate, TSchema> {
    const traitNames: string[] = traitsAndDefaults.filter((arg) => typeof arg === 'string');
    const hooks: FactoryAfterCreateHook<TSchema, TTemplate>[] = [];

    if (this.afterCreate) {
      hooks.push(this.afterCreate);
    }

    traitNames.forEach((name) => {
      const trait = this.traits[name as TraitName<TTraits>];

      if (trait?.afterCreate) {
        hooks.push(trait.afterCreate);
      }
    });

    // Execute hooks with the properly typed model instance and schema
    hooks.forEach((hook) => {
      (hook as (model: ModelInstance<TTemplate, TSchema>, schema: SchemaInstance<TSchema>) => void)(
        model,
        schema,
      );
    });

    return model;
  }

  // -- PRIVATE METHODS --

  private _processAttributes(
    attrs: FactoryAttrs<TTemplate>,
    modelId?: ModelId<TTemplate>,
  ): PartialModelAttrs<TTemplate, TSchema> {
    const attributes = attrs as PartialModelAttrs<TTemplate, TSchema>;
    const keys = this._sortAttrs(attributes, modelId);

    const result = keys.reduce((acc, key) => {
      const value = attributes[key];

      if (typeof value === 'function') {
        return {
          ...acc,
          [key]: value.call(attrs, modelId),
        };
      }

      return acc;
    }, attributes);

    return result;
  }

  private _buildWithTraits(
    traitNames: string[],
    modelId?: ModelId<TTemplate>,
  ): PartialModelAttrs<TTemplate> {
    const result = traitNames.reduce(
      (traitAttributes, name) => {
        const trait = this.traits[name as TraitName<TTraits>];

        if (trait) {
          const { afterCreate: _, ...extension } = trait;

          for (const key in extension) {
            const value = extension[key as keyof typeof extension];
            // Skip id and association objects
            if (key !== 'id' && !this._isAssociation(value)) {
              traitAttributes[key] =
                typeof value === 'function' ? value.call(this.attributes, modelId) : value;
            }
          }
        }

        return traitAttributes;
      },
      {} as Record<string, any>,
    );

    return result as PartialModelAttrs<TTemplate>;
  }

  /**
   * Check if a value is an association object
   * @param value - The value to check
   * @returns True if the value is an association
   */
  private _isAssociation(value: any): boolean {
    return (
      typeof value === 'object' &&
      value !== null &&
      'type' in value &&
      'model' in value &&
      ['create', 'createMany', 'link', 'linkMany'].includes(value.type)
    );
  }

  /**
   * Extract associations from traits
   * @param traitsAndDefaults - The trait names to extract associations from
   * @returns The merged associations from all traits
   */
  private _getTraitAssociations(
    traitsAndDefaults?: (TraitName<TTraits> | PartialModelAttrs<TTemplate, TSchema>)[],
  ): FactoryAssociations<TTemplate, TSchema> {
    if (!traitsAndDefaults) {
      return {};
    }

    const traitNames = traitsAndDefaults.filter((arg) => typeof arg === 'string') as string[];
    const associations: Record<string, any> = {};

    traitNames.forEach((name) => {
      const trait = this.traits[name as TraitName<TTraits>];

      if (trait) {
        for (const key in trait) {
          const value = trait[key];
          if (this._isAssociation(value)) {
            associations[key] = value;
          }
        }
      }
    });

    return associations as FactoryAssociations<TTemplate, TSchema>;
  }

  private _mergeAttributes(
    baseAttributes: PartialModelAttrs<TTemplate>,
    overrideAttributes: PartialModelAttrs<TTemplate>,
  ): PartialModelAttrs<TTemplate> {
    return {
      ...baseAttributes,
      ...overrideAttributes,
    };
  }

  private _sortAttrs(
    attrs: PartialModelAttrs<TTemplate, TSchema>,
    modelId?: ModelId<TTemplate>,
  ): (keyof PartialModelAttrs<TTemplate, TSchema>)[] {
    const visited = new Set<string>();
    const processing = new Set<string>();

    const detectCycle = (key: string): boolean => {
      if (processing.has(key)) {
        throw new MirageError(`Circular dependency detected: ${String(key)}`);
      }
      if (visited.has(key)) {
        return false;
      }

      processing.add(key);

      const value = attrs[key as keyof PartialModelAttrs<TTemplate, TSchema>];
      if (typeof value === 'function') {
        // Create a proxy to track property access
        const proxy = new Proxy(attrs, {
          get(target, prop) {
            if (typeof prop === 'string' && prop in target) {
              detectCycle(prop);
            }
            return target[prop as keyof typeof target];
          },
        });

        // Call the function with the proxy as this context
        (value as Function).call(proxy, modelId);
      }

      processing.delete(key);
      visited.add(key);
      return false;
    };

    // Check each attribute for cycles
    Object.keys(attrs).forEach(detectCycle);

    // Return keys in their original order
    return Object.keys(attrs) as (keyof PartialModelAttrs<TTemplate, TSchema>)[];
  }
}
